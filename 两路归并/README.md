# 两路归并

[TOC]

## 题目

给定 k 个排好序的序列 s1,s2,...,sk， 用 2 路合并算法将这 k 个序列合并成一个序列。

假设所采用的 2 路合并算法合并 2 个长度为 m 和 n 的序列需要 m+n-1次比较。

设计一个算法确定 2 路合并次序， 使所需的总比较次数最少。

## 分析

### 输入

只需要一个 k 值，以及一个一维数组 data[k] 即可。可以看出 k 值只是一个控制条件。

> 给定 k 个排好序的序列 s1,s2,...,sk

### 输出

输出一个数值，比较 k-1 次累加的值。下面用数据详细说明：

### 举例

我们的数据如下：

```
n = 5;(也就是k值）
data[n] = {4,2,5,7,9};
num = 0;(输出的数值，代表比较次数，但下面的算法中不需要此值)
```

data 数组内的数字含义是什么，代表各个序列的长度，也是 m、n值的取值。

比如我们要合并 data[0] 和 data[1] 位置的序列，它们会合并成一个长度为 6 (4+2）的序列，而这次合并中，6个数字一共会比较 5 (6-1) 次，合并后，num += 5。

同理，合并data[2]和data[3]位置的序列，它们会合并成一个长度为 11 (5+7）的序列，而这次合并中，11个数字一共会比较 10 (11-1) 次，合并后，num += 10。

...

易知，若想输出值最小，我们需要从小数值开始合并，也就是每次合并的时候，选择最小的值和第二小的值进行合并。（采用的是贪心算法，证明过程请查阅其他资料）

### 个人算法说明

对上述数组进行由小到大的排序：

```c++
data[n] = {4,2,5,7,9};
sort(data, data+n); //将数组从小到大排列
data[n] = {2,4,5,7,9}; 
```

我们不需要 num 值来表示输出值，我们直接在此数组内累加即可，将累加值存入第二个位置。需注意，每次累加前都要保证数组值是由小到大：

```c++
data[1] = data[0] + data[1] - 1;
data[n] = {2,5,5,7,9}; //第一次累加
data[2] = data[1] + data[2] - 1;
data[n] = {2,5,9,7,9}; //第二次累加
```

这时我们发现，data[2]的值大于data[1]的值，而我们的要求是数组值是由小到大，这时就需要调整数值位置：

```c++
int j = 0; 
for(int i=0; i<n-2; i++) { 
    data[i+1] += data[i] - 1;
    j = i+1; 
    while(data[j]>data[j+1]) {
        swap(data[j], data[j+1]);
        j++; 
    }
}

//第二次累加后，i,j指向说明：
2	5	9	7	9
	i	j 	j+1
```

这里 i 是存入累加值前面一位的下标，所以其中我选用新变量 j 来进行小幅度排序。将 j 设为累加值的下标，如果它大于后面的值，就进行交换，依次将此值至于合适位置，保证数组值的有序性。再进行下一轮累加：

```c++
data[n] = {2,5,7,9,9}; //第一次排序后
data[3] = data[2] + data[3] - 1;
data[n] = {2,5,7,15,9}; //第三次累加
data[n] = {2,5,7,9,15}; //第二次排序后
```

此时已经经过了三次累加，i = 2，还有最后一次累加没有完成。

但若进行下一次累加，i = 3，j = 4，进入 while 循环判断，j+1 = 5，而此数组只有5个数，j+1 值越界。所以为了避免 Bug，最后一次累加在循环外进行：

```c++
//修正最后一项，它前面的数加上它本身就是最少次数了
data[n-1] += data[n-2] - 1;
```

此时的 data[n-1] 就是我们需要输出的值，也就是最少比较次数。



## 代码

注：main.cpp文件仅包含运行代码，如需每一步代码的详细解释，请查看main_note.cpp文件。

```c++
/*
 * @Author: evgo 
 * @Date: 2018-06-10 19:26:59 
 * @Last Modified by: evgo
 * @Last Modified time: 2018-06-10 21:23:04
 * @Email: evgo2017@qq.com 
 * @Github: evgo2017
 * @Blog: http://evgo2017.com
 */

/*两路归并*/

#include <iostream>
#include <algorithm>
#define n 5
using namespace std;

void swap(int &x, int &y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int data[n] = {4,2,5,7,9};
    sort(data, data+n); 

    int j = 0;
    for(int i=0; i<n-2; i++) { 
        data[i+1] += data[i] - 1;

        j = i+1;
        while(data[j]>data[j+1]) {
            swap(data[j], data[j+1]);
            j++; 
        }
    }
    data[n-1] += data[n-2] - 1;

    cout<<data[n-1];
    return 0;
}
```

