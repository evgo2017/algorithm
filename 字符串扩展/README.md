# 字符串比较问题（扩展距离）

这是一道关于动态规划的算法问题。建议文章与注释版代码一起查看。

[TOC]

## 题目

对于长度相同的 2 个字符串 A 和 B， 其距离定义为相应位置字符距离之和。2 个非空格字符的距离是它们的 ASCII码之差的绝对值。 空格与空格的距离为 0，空格与其他字符的距离为一定值 k。在一般情况下， 字符串 A 和 B 的长度不一定相同。 字符串 A 的扩展是在 A 中插入若干空格字符所产生的字符串。 在字符串 A 和 B 的所有长度相同的扩展中， 有一对距离最小的扩展，该距离称为字符串 A 和 B 的扩展距离。算法要求如下：

​	1、 数据输入： 第 1 行是字符串 A， 第 2 行是字符串 B， 第 3 行是空格与其他字符的距离定值 k。
​	2、 输出： 字符串 A 和 B 的扩展距离。

## 举例

输入：

```
cmc
snmn
2
```

输出：

```
10
```

**注**： 设字符串 A 和 B 的子串 A[1..i]和 B[1..j]的扩展距离为 val(i,j)，则 val(i,j)具有最优子结构性质， 递归定义为：val(i,j)=min{val(i-1,j)+k, val(i,j-1)+k, val(i-1,j-1)+dist(ai,bj)}

## 解析

### 解析题目

题目输入两个字符串，以及一个数字Ｋ；输出一个数字，代表两个字符串的**扩展距离**。



！！！！！！！！！！！！！！！

！！（ 下划线 '_' 代表空格 ） ！！

！！！！！！！！！！！！！！！



**扩展字符串**：当两个不等长的字符串，比如A字符串“cmc”，B字符串“snmc"。A字符串的长度为3，而B字符串长度为4，但是在Ａ字符串插入一个**空格字符**后，它的长度就变成４了，与Ｂ等长，比如Ａ字符串”c_mc“。

> 字符串 A 的扩展是在 A 中插入若干空格字符所产生的字符串。



**字符距离**：两个非空格字符之间的ASCII码的差值；而两个空格字符或非空格字符，它们之间的距离就是0，因为是同一个字符，之间当然没有距离了；那么一个空格字符和一个非空格字符的字符距离是多少？就是我们输入的**K值**了。

> 2 个非空格字符的距离是它们的 ASCII码之差的绝对值。 空格与空格的距离为 0，空格与其他字符的距离为一定值 k。



**扩展距离**：假设有两个长度相同的字符串A与B，A[0]与B[0]位置的两个字符的字符距离，A[1]与B[1]位置的两个字符的字符距离，A[2]与B[2]位置的两个字符的字符距离...A[n]与B[n]位置的两个字符的字符距离，这些字符距离相加的**总和**就是扩展距离。而我们输出的这个扩展距离，就是多个扩展距离中，**值最小**的那个。

> 对于长度相同的 2 个字符串 A 和 B， 其距离定义为相应位置字符距离之和。

>在字符串 A 和 B 的所有长度相同的扩展中， 有一对距离最小的扩展，该距离称为字符串 A 和 B 的扩展距离。



为什么会有多个扩展距离？

以A字符串“cmc”，B字符串“snmc"举例：

Ａ字符串可以扩展为"_cmc"，”c_mc"，"cm_c"，"cmc\_"，"\_cm_c"，"\_c\_m\_c\_"等等，

B 字符串可以扩展为“s\_nmc"，“sn\_mc"，“snm\_c"，“s\_n\_mc"，“s\_nm\_c"，“\_snmc\_"，“\_snm\_c"等等。



**总结**：输出两个字符串的最小扩展距离。



以数据举例继续分析：

### 数据参考

这是题目举例中的字符距离数值表:

此时 Ａ字符串为"cmc"，B字符串为"snmc"，K = 2：

| 字符距离  | **s** | **n** | **m** | **n** |
| ----- | ----- | ----- | ----- | ----- |
| **c** | 16    | 11    | 10    | 11    |
| **m** | 6     | 1     | 0     | 1     |
| **c** | 16    | 11    | 10    | 11    |

| 字符距离  | s    | n    | m    |
| ----- | ---- | ---- | ---- |
| **c** | 16   | 11   | 10   |
| **m** | 6    | 1    | 0    |

先让 A 字符串中 "c" 字符与B字符串中的各个字符分别配对，字符距离分别为 16、11、10，而若"c"字符与空格字符配对，也就是"c"字符相对位置为"_"（空格），此时字符距离为 k 值 2；可见大大减少了字符距离，相应也大大减少了扩展距离。

同理 A 字符串中 "m" 字符，字符距离分别为 6、 1、 0，此时若对应空格则是2，反而增加了字符距离。

上述分析不代表最后结果，只是分析一下关键点。



### 公式分析

> 设字符串 A 和 B 的子串 A[1..i]和 B[1..j]的扩展距离为 val(i,j)，则 val(i,j)具有最优子结构性质， 递归定义为：val(i,j)=min{val(i-1,j)+k, val(i,j-1)+k, val(i-1,j-1)+dist(ai,bj)}

	val(i,j) = min{
	  val(i-1,j)+k, 
	  val(i,j-1)+k, 
	  val(i-1,j-1)+dist(ai,bj)
	}

在数组中，更新某下标为 i 和 j 的位置的内部值：它左边的位置内的数+k，上方的位置内的数+k，左上方的位置内的数+此位置内的数字，这三个数字内，最小的数字填入此位置。



**举例：**

新建一个二维数组A\[n\]\[m\]，n 是第一个字符串的长度+1，m 是第二个字符串的长度+1，第一行和第一列的值设置为 k*i (i=0,1,2..)。

字符串 A 为”cmc“，字符串 B 为”snmn“，所以数组为 A\[4\]\[5\]， 各个字符距离填入下表：

|   0   |  2   |  4   |  6   |  8   |
| :---: | :--: | :--: | :--: | :--: |
| **2** |  16  |  11  |  10  |  11  |
| **4** |  6   |  1   |  0   |  1   |
| **6** |  16  |  11  |  10  |  11  |



再由A\[1\]\[1\]开始，由左至右，由上至下进行递归（由上至下，由左至右也可以），更新每个位置的值（ i, j >0)。

此时更新A\[1\]\[1\]位置的值，A\[0\]\[1\] + 2 = 4，A\[1\]\[0\] + 2 = 4，A\[0\]\[0\] + 16 = 16，所以A\[1\]\[1\]的值更新为 4。其他位置同理。



使用公式递归后：

|   0   |  2   |  4   |  6   |  8   |
| :---: | :--: | :--: | :--: | :--: |
| **2** |  4   |  6   |  8   |  10  |
| **4** |  6   |  5   |  6   |  8   |
| **6** |  8   |  7   |  8   |  10  |

最下角的数字就是最小扩展距离。

对于此解法的原理，请参考动态规划问题类的文章。



## 代码(注释版请查看main_note.cpp源文件)

注：main.cpp文件仅包含运行代码，如需每一步代码的详细解释，请查看main_note.cpp文件。

```c++
/*
 * @Author: evgo 
 * @Date: 2018-06-10 14:08:36 
 * @Last Modified by: evgo
 * @Last Modified time: 2018-06-10 17:14:08
 * @Email: evgo2017@qq.com 
 * @Github: evgo2017
 * @Blog: http://evgo2017.com
 */

/* 字符串扩展距离 */

#include <iostream>
using namespace std;

int dist(char a, char b) {
    return abs(a-b);     
}
int min(int x, int y, int z){
    if(x<y) {
        return x<z?x:z;
    }
    return y<z?y:z;
}
int main() {
    string s1, s2; 
    int k; 
    cin>>s1>>s2>>k;
    
    s1 = " " + s1;    
    s2 = " " + s2;    
    
    int len1 = s1.length(),
        len2 = s2.length(),
        val[len1][len2] = {0}; 
        
    for(int i=1; i<len1; i++) {
        val[i][0] = k * i;
    }
    for (int j=1; j<len2; j++) {
        val[0][j] = k * j;
    }
    for(int i=1; i<len1; i++) {
        for (int j=1; j<len2; j++) {
            val[i][j] = dist(s1[i], s2[j]);
        }
    }

    for (int i = 1; i <= len1; i ++) {
        for (int j = 1; j <= len2; j ++) {
            val[i][j] = min(val[i-1][j]+k, val[i][j-1]+k, val[i-1][j-1]+dist(s1[i],s2[j]));
        }
    } 
    cout<<val[len1-1][len2-1];
    return 0;
}
```

